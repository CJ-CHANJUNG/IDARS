# 실무 중심의 IDARS 에이전트 도입 가이드 (Beginner-Friendly Guide)

이 문서는 AI 전문가가 아니더라도 이해할 수 있도록, **"신입 사원(AI)을 채용해서 가르치는 과정"**에 비유하여 작성했습니다.

---

## 1. 전체 그림: 무엇을 하려는 건가요?

지금까지의 프로그램은 **"계산기"**와 같았습니다. 입력하면 정해진 공식대로만 답이 나왔죠. 조금만 틀려도 에러가 났습니다.
이제 우리가 만들려는 것은 **"똑똑한 인턴 사원"**입니다.
*   **계산기**: "이 칸에 있는 숫자를 더해." (칸이 밀리면 못함)
*   **인턴(AI)**: "이 서류에서 '합계'를 찾아서 더해. 만약 합계가 안 보이면 '소계'랑 '세금'을 더해서 계산해봐." (융통성 있음)

우리는 이 "인턴"을 3명 채용할 겁니다.
1.  **분류 담당 (Splitter)**: 서류 뭉치를 받아서 종류별로 나누는 친구.
2.  **입력 담당 (Extractor)**: 서류 내용을 엑셀에 옮겨 적는 친구.
3.  **감사 담당 (Reconciler)**: 엑셀 내용과 원장(ERP)을 비교해서 틀린 걸 찾는 친구.

---

## 2. 단계별 실무 가이드

### 1단계: 분류 담당 (Splitter Agent) 만들기

**목표**: 뒤죽박죽 섞인 PDF 파일을 받아서 "여기부터 여기까지는 인보이스 A, 저기는 인보이스 B"라고 나누기.

*   **어떻게 작동하나요?**
    *   기존에는 "바코드가 있으면 잘라"라고 코딩했습니다.
    *   이제는 AI에게 **"첫 페이지를 보여주고, 이게 새로운 문서의 시작인지 판단해"**라고 시킵니다.
    *   AI는 "페이지 상단에 큰 글씨로 INVOICE라고 써있고, 날짜가 바뀌었으니 새로운 문서입니다"라고 판단합니다.

*   **실무 구현 방법**:
    1.  PDF의 각 페이지를 **이미지**로 변환합니다.
    2.  AI(Gemini)에게 이미지를 보여주며 물어봅니다.
        > "이 페이지가 앞 페이지랑 이어지는 내용이니? 아니면 새로운 문서의 표지니?"
    3.  AI가 "새 문서요"라고 하면 거기서 파일을 자릅니다.

*   **어떻게 가르치나요? (학습)**
    *   처음엔 AI가 실수를 할 수 있습니다. (예: 첨부파일을 새 문서로 착각)
    *   사용자가 "아니야, 이건 앞 문서의 첨부파일이야"라고 **수정 버튼**을 누릅니다.
    *   시스템은 이 사례를 기억장치(DB)에 저장합니다.
    *   다음번에 비슷한 첨부파일이 나오면, AI는 기억장치를 뒤져서 **"아! 지난번에 사수님이 이런 건 첨부파일이라고 했어"**라고 스스로 교정합니다.

---

### 2단계: 입력 담당 (Extractor Agent) 만들기

**목표**: 문서에서 날짜, 금액, 품목 등을 찾아서 엑셀(DB)에 넣기.

*   **어떻게 작동하나요?**
    *   기존에는 "위에서 3번째 줄, 왼쪽에서 5번째 칸을 읽어"라고 했습니다. (양식이 조금만 바뀌면 망함)
    *   이제는 AI에게 **"이 문서에서 'Total Amount'에 해당하는 숫자를 찾아줘. 통화 기호($)는 빼고 숫자만 줘"**라고 시킵니다.

*   **실무 구현 방법**:
    1.  **"검증 규칙"**을 미리 정해둡니다. (예: 수량 × 단가 = 금액)
    2.  AI가 데이터를 추출해오면, 프로그램이 몰래 계산을 해봅니다.
    3.  만약 계산이 안 맞으면, AI에게 다시 시킵니다.
        > "야, 너가 가져온 금액이랑 수량이랑 곱해보니까 안 맞잖아. 다시 확인해봐." (Self-Correction)
    4.  AI는 "죄송합니다. 다시 보니 할인 금액이 숨어있었네요"라며 고쳐옵니다.

*   **어떻게 가르치나요? (학습)**
    *   특이한 양식(예: 손으로 쓴 메모)이 나와서 AI가 못 읽으면, 사용자가 직접 입력해줍니다.
    *   시스템은 **"이런 모양의 글자는 이렇게 읽는 거야"**라고 예시를 저장해둡니다. (Few-Shot Learning)

---

### 3단계: 감사 담당 (Reconciler Agent) 만들기

**목표**: 우리가 입력한 내용과 회사 장부(ERP)가 맞는지 확인하기.

*   **어떻게 작동하나요?**
    *   기존에는 "글자가 토씨 하나라도 다르면 불일치"로 떴습니다. (Samsung ≠ Samsung Elec)
    *   이제는 AI가 **"문맥"**을 봅니다. "이건 회사 이름 줄임말이니까 같은 거야."

*   **실무 구현 방법**:
    1.  두 데이터를 나란히 놓고 AI에게 물어봅니다.
        > "왼쪽은 우리 장부고, 오른쪽은 거래처 인보이스야. 금액이 10달러 차이나는데 왜 그런 것 같아?"
    2.  AI는 내용을 분석해서 추리합니다.
        > "인보이스 하단에 'Bank Charge $10'이라고 적혀있네요. 이것 때문에 차이가 나는 겁니다. 내용은 일치합니다."
    3.  사용자에게는 **"일치함 (단, 은행 수수료 차이 있음)"**이라고 보고합니다.

---

## 4. 비용 및 인프라 최적화 (Cost & Infrastructure)

월 1,000건 이상의 문서를 처리하려면 **비용 효율성**이 매우 중요합니다. 무조건 비싼 AI를 쓰는 게 아니라, 적재적소에 배치해야 합니다.

### A. 데이터베이스 (기억장치) 구현 방향
거창한 서버가 필요 없습니다. **로컬 벡터 DB (ChromaDB)**를 추천합니다.
*   **왜 벡터 DB인가요?**: "삼성전자"와 "Samsung Elec"가 비슷하다는 걸 AI가 이해하려면, 글자를 숫자로 바꾼 '벡터'로 저장해야 하기 때문입니다.
*   **구현**: 프로그램 안에 내장되는 가벼운 파일 형태의 DB입니다. (설치 불필요, 엑셀 파일처럼 폴더에 저장됨)
*   **비용**: **0원** (오픈소스 사용).

### B. API 비용 절감 전략 (월 1,000건 기준)
모든 건에 최고급 AI(Gemini Pro)를 쓰면 비쌉니다. **"하이브리드 전략"**을 씁니다.

1.  **1차 처리 (Gemini Flash)**: 속도가 빠르고 가격이 매우 저렴한 모델입니다. (Pro 대비 1/20 가격)
    *   대부분의 정형화된 인보이스는 이걸로 처리합니다.
2.  **2차 처리 (Gemini Pro)**: Flash가 "모르겠어요" 하거나, 사용자가 수정한 복잡한 건만 Pro에게 맡깁니다.
3.  **캐싱 (Caching)**: 한 번 분석한 양식은 결과를 저장해둡니다. 똑같은 양식이 들어오면 API를 호출하지 않고 저장된 규칙을 씁니다.

**예상 비용 시뮬레이션 (월 1,000건)**
*   **Gemini 1.5 Flash**: 1건당 약 10~20원 수준 -> 월 1~2만원 내외.
*   **Gemini 1.5 Pro**: 1건당 약 200~300원 수준 -> 필요한 경우만 사용.
*   **결론**: 월 1,000건 처리 시 **약 3~5만원** 수준으로 운영 가능하도록 설계합니다. (사람이 하는 인건비 대비 압도적으로 저렴)

---

## 6. 상세 작동 메커니즘 (Detailed Mechanism)

사용자분이 궁금해하신 **"구체적으로 어떻게 작동하고, 학습하고, DB를 쓰는지"**에 대한 답변입니다.

### A. 진행 방향: 기존 방식 vs 에이전트 방식
*   **기존**: `파일 업로드` -> `정해진 규칙(Splitter)` -> `정해진 규칙(Extractor)` -> `결과`
    *   *문제*: 규칙에서 벗어나면 바로 에러.
*   **에이전트 방식**: `파일 업로드` -> **`AI 에이전트(판단)`** -> `결과`
    *   *차이점*: 에이전트가 중간에 개입하는 게 아니라, **기존의 규칙 기반 코드를 에이전트가 대체**합니다.

### B. 구체적 작동 시나리오 (A Day in the Life of a Document)

1.  **상황**: "손으로 쓴 메모가 붙은 인보이스"가 들어왔습니다.
2.  **에이전트의 판단 (Retrieval)**:
    *   에이전트는 먼저 **벡터 DB(ChromaDB)**를 봅니다.
    *   *"과거에 이런 손글씨 메모를 처리한 적이 있나?"* (검색)
3.  **프롬프트 구성 (Prompting)**:
    *   에이전트는 검색된 과거 사례를 참고하여 프롬프트를 만듭니다.
    *   > **지시**: "이 문서를 읽어. 주의할 점: 과거 사례 #123처럼 '손글씨 메모'는 무시하지 말고 '비고' 란에 적어."
4.  **실행 및 결과**:
    *   AI는 지시대로 손글씨를 읽어서 '비고'에 넣고 결과를 출력합니다.

### C. 학습(Learning)은 어떻게 이루어지나?
"학습"이라고 해서 거창한 모델 훈련(Training)을 하는 게 아닙니다. **"오답 노트 만들기"**에 가깝습니다.

1.  **오류 발생**: AI가 실수로 손글씨를 빠뜨렸습니다.
2.  **사용자 피드백**: 사용자가 화면에서 "이거 빠졌어"라고 입력하고 저장합니다.
3.  **벡터 DB 저장**:
    *   시스템은 **[당시의 문서 이미지 + 사용자의 수정 내용]**을 짝지어서 `backend/data/chroma_db` 폴더에 저장합니다.
    *   이때 텍스트뿐만 아니라 이미지의 특징도 숫자로 변환(임베딩)해서 저장합니다.
4.  **다음번 적용**:
    *   다음에 비슷한 문서가 들어오면, 벡터 DB가 *"어? 이거 지난번에 틀렸던 그 문서랑 비슷하게 생겼는데요?"*라고 알려줍니다.
    *   그러면 AI는 **"아 맞다, 이런 건 조심해야지"**라고 스스로 교정합니다.

### D. 벡터 DB는 어디에?
*   **위치**: 사용자 컴퓨터의 `backend/data/chroma_db` 폴더에 파일 형태로 저장됩니다.
*   **특징**: 인터넷 연결이 끊겨도 내 컴퓨터에 저장된 "지식"은 유지됩니다. 엑셀 파일처럼 복사/백업도 가능합니다.

---

## 7. 현재 방식(Smart Extractor) vs 에이전트(Agent) 비교

사용자분이 궁금해하신 **"지금 쓰고 있는 거랑 뭐가 다르고, 비용은 얼마나 차이나나?"**에 대한 비교입니다.

| 구분 | 현재 방식 (Smart Extraction Engine) | 제안된 에이전트 (Extractor Agent) |
| :--- | :--- | :--- |
| **작동 방식** | **단답형 (One-Shot)**<br>"이거 읽어줘" -> 끝.<br>(값이 비어있으면 똑같이 3번 재시도) | **대화형/추론형 (Reasoning)**<br>"이거 읽어줘" -> (검증) -> "합계가 안 맞네? 다시 찾아봐" -> (수정) -> 완료 |
| **학습 능력** | **없음**<br>코드를 직접 수정하지 않는 한 똑같은 실수를 반복함. | **있음 (Few-Shot)**<br>사용자가 한 번 고쳐주면, 다음부터는 그 사례를 참고해서 정답을 맞춤. |
| **프롬프트** | 고정된 명령어 (Static Prompt) | **동적 명령어 (Dynamic Prompt)**<br>상황에 따라, 과거 사례에 따라 명령어가 바뀜. |
| **토큰 사용량** | **적음** (이미지 + 기본 명령어) | **약간 많음** (이미지 + 기본 명령어 + **과거 유사 사례**) |
| **예상 비용** | 1건당 약 10원 (Flash 기준) | 1건당 약 15~20원 (Flash 기준)<br>*참고 사례가 추가되어 입력량이 늘어남* |

### 💡 핵심 요약
*   **비용 차이**: 1건당 5~10원 차이로 **미미합니다.** (Flash 모델이 워낙 저렴하기 때문)
*   **성능 차이**: "학습 능력" 유무가 큽니다. 현재 방식은 1,000번을 해도 똑같은 실수를 하지만, 에이전트는 10번만 고쳐주면 나머지 990번은 잘하게 됩니다.

---

## 8. 추가 질문에 대한 답변 (Q&A)

### Q1. OCR이 못 읽는 부분(손글씨, 도장 등)도 커버가 되나요?
**네, 훨씬 강력합니다.**
*   **기존 방식**: 글자를 텍스트로 바꾼 뒤에 찾기 때문에, OCR이 실패하면(예: `O`를 `0`으로 인식하거나, 도장에 가려진 글자) 데이터를 절대 못 찾습니다.
*   **에이전트 방식 (VLM)**: 사람처럼 **"이미지 그 자체"**를 봅니다.
    *   글자가 뭉개져 있어도 주변 문맥을 보고 "이건 Total Amount 자리니까 숫자겠구나"라고 추론합니다.
    *   도장이 찍혀서 글자가 가려져도, 흐릿한 윤곽을 보고 읽어냅니다.
    *   심지어 **손으로 쓴 메모**나 **체크 표시(✓)**도 이해합니다.

### Q2. OCR은 됐는데 기존 프로그램이 놓치는 자료도 찾을 수 있나요?
**네, "추론 능력" 때문에 가능합니다.**
*   **기존 방식**: "Total"이라는 단어 옆에 있는 숫자만 가져옵니다. 만약 문서에 "Total" 대신 "Grand Sum"이라고 써있으면 못 찾습니다.
*   **에이전트 방식**:
    *   **동의어 이해**: "Grand Sum", "Amount Payable", "Total Due"가 전부 같은 말이라는 걸 압니다.
    *   **계산 추론**: 합계 금액이 안 적혀 있으면, **"단가 × 수량 = 합계"**를 직접 계산해서 빈칸을 채워 넣습니다.
    *   **위치 추론**: 표가 깨져서 줄이 안 맞아도, "이 숫자는 'Price' 열 아래에 있으니까 가격이네"라고 위치를 보고 판단합니다.

---

## 9. 결론 및 제안
이 방식은 **"쓰면 쓸수록 똑똑해지는 시스템"**입니다. 처음에는 사용자가 좀 가르쳐야 하지만, 데이터가 쌓일수록 손댈 일이 없어집니다.

**[최종 제안]**
가장 먼저 **"입력 담당(Extractor) 에이전트"**를 만들어서, 기존의 `SmartExtractionEngine`을 대체해보는 것이 좋겠습니다.
이 과정에서 **LangChain**과 **ChromaDB**를 세팅해드리겠습니다. 진행할까요?
